### 昨天的新问题

#### 1. compact string

关于java 9之后改变string的底层存储类型。
官方给出的意思就是如果String中只使用Latin-1的character的话就是使用一个byte来储存（ISO-8859-1），
这样可以大大节约空间，因为大部分英文和数字都是Latin-1。但是如果碰上非Latin-1的string
那么就应该使用UTF-16来进行储存。具体的一些我找到的区别放在下面这张表里面了。<br>

|         | ISO-8859-1                   |         UTF-8          |         UTF-16         |
|:-------:|------------------------------|:----------------------:|:----------------------:|
|  Byte   | 1                            |         1/2/3          |          2/4           |
| Support | first 256 unicode characters | any unicode characters | any unicode characters |
|  ASCII  | 完美支持                         |          完美支持          |          完美支持          |

基本上可以看出来，只用Latin-1字符的话，使用ISO-8859-1确实可以节省大量空间。因为UTF-16最少也得是2个字节。
这样的话势必会有一般的空间被浪费。<br>
观察了以下源码发现了String class中有一个静态的代码块

```shell
static final boolean COMPACT_STRINGS;

static {
    COMPACT_STRINGS = true;
}
```

稍微看了一看这个的演变史，在java 6的时候compressed string算是一个JVM的option，可以自己开启。
但是java 9之后，这个部分算是自动开启的，也可以手动输入```+XX:-CompactStrings```来关闭。
然后具体的实现也稍微做了改动，java 6的时候没有开源，所以不知道逻辑是什么样的。但是java 9以后通过看String的源码会发现，
所有的string对象都被加上coder这个属性。coder只可以LATIN-1或者UTF-16，并且不可更改。
coder使用0表示LATIN-1；1表示UTF-16。

#### 2. JVM参数打印

方式有很多种，主要是看需要打印的是什么类型的参数。<br>
> 直接打印所有参数：```java -XX:+PrintFlagsFinal -version > paras.txt```
> 通过JVM的参数就可以观察很多设置，比如这两天一直研究的String，JVM里面就有很多选项。
> <br>目前比较相关的就是uintx StringTableSize = 65536 {product} {default}，
> 这个数值记录了默认的StringTable的大小。还有bool CompactStrings = true {pd product} {default}，
> 也是刚才讨论到的JVM会自动开启compact strings这个功能。

### TASK 2609

本次任务具体实现了三个类，餐馆，火锅店，咖啡馆。其中火锅店和咖啡馆继承了餐馆。
不同于之前的任务，本次尝试使用抽象类来定义餐馆，从而相对提高可移植性。
在定义不同的fields的时候使用了不同的修饰符。具体会在后面详细的解释。

#### 继承

java中继承一般就使用extends来进行，并且每一个子类只能继承一个父类。就如果父子关系一样，
子类一般可以继承父类的一些特征，比如fields和方法。并且也可以使用父类的构造器，但是这里要特别注意不同的修饰符对于继承的影响。
包括父类的类型和子类的类型都会有各种各样的限制。

##### super关键字

super关键字，我个人理解是```总的来说，使用它可以获取父类的变量和方法```。super和this一样，
都属于一个具体实例的隐式参数，因此不可以用在static的方法中。因为static修饰的方法和参数，实际上是属于类的。
所以super也可以看成是父类的一个实例。
> 在构造器中使用super的话，实际上就是调用父类的构造器。比较特殊的地方在于，
> 如果子类的构造器中没有使用super，javac会在子类的构造器中自动加入一个super()来调用父类的构造器。
> 这里很奇怪，我查看了反编译结果，但是没有没有看到子类构造器里面的super()。可能是反编译结果不准确导致的。
> 其他值得注意的地方是，使用super和this的构造器，一定要把他们放在第一行。原因主要是，使用了super和this的构造器，
> 实际上是覆盖了javac自动添加的super()构造器，如果不放在第一行，则会被javac自动添加的所覆盖，也就无法编译成功。

> 好几篇文章都提到构造器中使用super()的话也需要注意，父类里必须有这个构造器。如果父类中没有这个构造器，
> 那么就会报错。但是我尝试了一个例子，用B继承A。然后A里面什么都没有放，在B的构造器里面使用了super()，
> 结果依旧可以compile而且还可以运行和正常打印。我尝试分析原因后得出以下结论。
> 因为javac其实在编译的时候会自动给没有无参构造器的class自动添加一个无参构造器，所以虽然在A里面，
> 我没有手动的加入无参构造器，但是编译的时候由于，创建B的实例的时候会先创建B的父类，也就是A。所以javac会自动加入一个A的无参构造器，
> 然后在编译B的构造器，这时候由于无参构造器已经被javac加入了，所以就不会产生问题了。<br>
> 但是此方法必须满足父类中不能有其他构造器。比如我尝试了以下方法：

```shell
public class A {
    protected int id;
    public A(int id) {
        this.id = id; 
    }
}

public B() {
        super();
        System.out.println("B的构造器");
    }
```

此时B的super()就会爆红，因为A已经有了一个非自动的构造器，所以javac不会在创建一个单独的无参构造器给它了。

PS：在构造器中使用this()的原因<br>
问了Ryan，一个是可以减少代码的重复，因为如果我有三个参数，我可以使用前面已经定义好地含2个参数的构造器。
这样就可以减少一直重复写this.var=var。还有一个可以更有条理性，可读性很强。

##### 修饰符的影响

> private <br>
> 如果父类使用了private修饰符修饰fields的话，那么它的子类是无法直接访问这些fields。
> 但是依旧可以通过setter和getter来访问。这里的话，我的一些思考是，如果我某些值，我不希望在子类的时候改动，
> 那么我就可以设置成private并且在父类里面删除setter。我想的一个例子就是类似于unique identifier，
> 比如学生号，或者客户的编号id。当我创建一个客户的时候，我可以定义他是一个vip，但是它的编号不可被修改。
> 这样保证了数据不会被随意替换。比如一个客户通过某种攻击手段来更改自己的资料。但是为了保证它能够被子类使用，
> 依然要保留getter。

> protected <br>
> 如果父类使用了protected来修饰fields的话，那么它的子类可以直接使用this或者super来访问或更改。
> 这里的话我用assert做了一个测试，```assert this.name == super.name```。IDEA直接warning，这个assert会一直为true。
> 所以对于protected的fields来说，super.和this.的结果可以随意互换。这里需要注意的是子类中没有和父类同名的fields。
> 如果有父类同名的fields那么可参考一下的结论。

> 同名变量 <br>
> 如果父类中使用了protected和public修饰成员变量。而子类中也有同样的名字话，则父类中的同名的变量会被直接隐藏。
> 这里需要注意的是只是隐藏起来，并不是这个变量就被覆盖了。在本次任务中，我在A的构造器中定义了id=10，而在B的构造器中定义了id=20。
> 然后分别打印super.id和this.id，会发现结果应该是10，20。这里侧面证明，其实虽然我只创建了一个子类实例，但是java还是会创建其父类实例。
> 并且这两个实例是分开储存数据的。这样做有什么好处我暂时还没想到，我目前的想法是，应该减少使用同名变量。
> 因为本身使用继承就是为了减少相同变量和方法一直复写，为什么还要单独使用同样的变量呢？而且还容易造成混淆。

> 同名方法 <br>
> 和上面相同，如果子类中有和父类同名的方法，那么该方法会直接覆盖父类的方法。这也是多态的一种表现形式。
> 这里比较常见的就是toString()。一般子类实例的toString会直接覆盖父类的toString。但是这里还有需要注意的就是，
> 父类中的静态方法是不会被覆盖的。比如下面这个例子：
> ```shell
> A:
> public static void print() {
>   System.out.println("我是A的print方法");
> }
> 
> B:
> public static void print() {
>   System.out.println("我是B的print方法");
> } 
> ```
> 如果在B Class中尝试写一个非static的print方法，就会直接报错。因为B继承了A，而A中的print又是static方法。
> B是不可以覆盖static方法的。这里原因感觉众说纷纭，我看了几个感觉上比较靠谱的。
> 对于非static方法，其实JVM是动态调度实现多态和覆盖的。也就是说具体使用了这个方法的时候才会进行调用。
> 但是static方法在JVM中似乎是直接编译的，因为它不会在被任何人更改。其实从字面意思上理解就是，
> static是静态，所以已经确定了，类似final不可更改。所以可以直接被javac编译，但是非static的方法，
> 其实是隐藏了关键字dynamic,也就是说不到最后一刻并不知道会使用哪一个。

##### 父子类直接的转换

强转父类<br>

```shell
    public static void abTest1() {
        A a1 = new A();
        B b1 = new B();
        b1 = (B) a1;
        System.out.println(b1);
    }

    public static void abTest2() {
        A a1 = new B();
        B b1 = new B();
        b1 = (B) a1;
        System.out.println(a1);
        System.out.println(b1);
    }
```

上面的代码中，test1会直接报错不给强转，而test2则可以没有问题，而且两个打印出来的东西是一致的。
所以这种强行的转制要求父类必须使用子类来构造，不然就无法进行转换。这里比较容易理解，因为假如一个咖啡厅和火锅都继承餐馆。
显然使用咖啡厅构造的餐厅不能直接转换到火锅餐厅。

##### 继承中的顺序问题

如果有一个C的继承了B，而B又继承了A。那么当创建一个C的实例的时候，实际上是先从A开始创建。
也就是说，所有的最底层的class在被构造的时候，会先找到最上层的构造器，一一按顺序构造，
其中如果父类的构造器有使用this()或者super()，那么也会先运行父类的构造器。如果任何类中包含静态代码块（静态域），
那么也会先执行静态域，再执行构造器，然后在继续子类。

##### 继承中的访问权限问题

目前没有想到一些比较好地使用场景，但是我觉得下面的用法可能在实际使用的时候会用到。
比如父类中的某个方法需要被外部调用，但是又不想被子类修改，那么可以使用public final来修饰。
java的好多源码中都用了这个方式，我想到的用法就是比如我需要取出某一个具体的客户的id，但是我又不希望子类修改这个方式。



