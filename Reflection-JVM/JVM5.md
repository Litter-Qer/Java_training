# 字节码

## 字节码指令

JVM的指令由一个操作码(Opcode)和多个操作数(Operand)组成。大部分的JVM采用面向操作数栈而非寄存器的架构，所以大部分的指令看不到操作数，而是把指令参数放在操作数栈中。
其实就类似汇编语言去除后面的地址啥的。

由于JVM限制一个操作码的长度为1个字节，所以最多只能由256个操作码。上一章提到了class文件编译后操作数的长度不是对齐的，所以处理超过一个字节的数据时，JVM会重建具体数据的结构。
比如一个16位无符号整数会用两个无符号的字节储存`(byte1 << 8) | byte2`。这种操作节省了大量的空间，但是会导致执行字节码的时候损失性能。

## 数据类型

一般JVM的操作码中都会包含它所需要的类型，比如`iload`是从局部变量表中加载一个int，也会出现比如goto等的与数据类型无关的指令。由于操作码只占有一个字节，
所以每个数据类型都设计一个操作码的话，256个指令是远远不够的。就像多线程中的享元模式，JVM会把一些相关的操作码关联到同一个操作码上，然后只储存那个操作码，
当数据类型出现变化的时候就直接转置。这里类似与泛型的概念，VM希望操作码可以根据需要进行改变。

## 加载和储存

`Tload`会把一个局部变量加载到操作数栈上，`Tstore`会把一个数值从操作数栈上存在局部变量表内，`bipush`等操作则会把一个常量加载到操作数栈。
这里的操作数栈其实存在在一个栈帧中。

## 运算指令

运算指令表示对两个操作数栈上的值进行特定运算，并且结果存会操作栈。VM基本上支持各种类型的运算包括加减乘除，取余，位移等。但是对整数和浮点的运算上会有些小的差别。
比如整数运算时，除数为0的时候就是会抛出一个异常，其余任何场景都不应该抛出异常。浮点运算时，如果有取舍的问题，会参照不同标准，有些时候可能导致精度问题。

## 类型转换

两种不同数值类型相互转换。Widening casting转换一般顺序为`byte -> short -> char -> int -> long -> float -> double`。
Narrowing casting的转换顺序则是`double -> float -> long -> int -> char -> short -> byte`。要特别注意，Widening casting可以是自动转置的，
因为它是安全的，所以怎么转都不会有问题。Narrowing casting必须手动，有意思的是JVM规范中规定虽然数据类型窄化转换可能会出现各种问题，但是这个指令不需要导致VM抛出异常。

## 对象创建与访问

其实前面也提到过，VM中对象分为类实例和数组。它们的创建方式略有不同。JVM指令中访问对象和创建的指令在前面的文章中也看过多次了，就不赘述了。

## 操作数栈管理指令

因为结构是栈，所以其实就是pop，dup和swap三个基本操作，没什么特别的。

## 控制转移指令

这个一般用来编译if，while，for等条件判断语句。主要作用就是保证在条件判定后，下一条要执行的指令(这个指令不是控制转移指令下一行，而是控制转移指令指定的一行)。
可以想象成直接修改寄存器的内容。类似c中的mov指令。

## 方法调用和返回指令

之前看过太多了，这里正好一并总结了

- `invokevirtual`: 用于调用对象的实例方法
- `invokeinterface`: 用于调用接口方法
- `invokespecial`: 用于调用一些特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法
- `invokestatic`: 用于调用静态方法
- `invokedynamic`: 运行时动态解析出调用点限定符

返回指令根据不同返回类型也会略有不同

## 异常处理指令

所有显示异常指令都会由`athrow`抛出，但是类似前面提到的ArithmeticException则是从`idiv`抛出。这里结合之前的class文件格式，JVM对于异常的处理并不是通过字节码实现，
而是改成异常表来实现，字节码中会规定处理完异常后的行数。

## 同步指令

JVM不仅支持方法级别的同步，也支持临界区的同步。无论是哪一种都是采取Monitor来实现的。对于方法的同步时隐式的，无需通过字节码指令来控制，它实现在方法调用和返回操作中。
VM可以从class文件方法常量池中的方法表的`access_flags`得知。当然由于时VM直接控制，所以锁的释放时自动的，无需考虑字节码的问题。关于这个`monitorenter`等相关的指令都现在线程进阶里面了。
所以就不做讨论了。

## 公有设计和私有设计

VM的公有设计其实就是《Java虚拟机规范》，只要保证这个所谓的接口对外一致，具体实现就是每个VM的私有设计了。其中最明显的就是Class文件的应用，只要你设计的是JVM，
那么对外就必须满足读取Class文件的正确性，至于怎么读，读出来的对象要怎么处理，就不是JVM规范关心的事情了。