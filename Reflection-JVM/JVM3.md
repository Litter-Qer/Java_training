# 虚拟机性能监控和故障处理工具

本章内容比较简单，都是工具类的使用我就直接略过了，其中的一些比较重要的工具我觉得还是要实际上手用比较好。也没有什么特别可以思考的点。

# 调优案例分析与实战

实际场景下的调优方案，这个大部分都是实际项目，因为我还没有正式接触项目，就针对书中给出的方案写一些自己的想法吧。可能会有很多不全面的地方，希望可以多提意见。

## 大内存硬件上的程序部署策略

案例：PV 15W/Day的网站，16G内存，64位操作系统。VM参数设置保证了堆大小稳定在12G。这里不讨论JDK版本的影响。限定条件下如何优化或者设计。
最初设计结果是用户能感受到明显的卡顿，由于GC的设计不合理导致经常进入Full GC，而且每次Full GC都会消耗超过10s。

分析：从问题来看，显然是GC的时间过长导致的，包括堆大小等内存参数设计不合理导致的full gc。由于实际的内存已有16G，在当年算是很大的容量，完全应该足够处理问题。
所以入手的角度应该还是JVM的参数，GC的种类，VM的种类。实现上述的策略比较直观的就是两种方法，第一种是只使用一个JVM管理所有的内存，第二种则是使用多个JVM模块化管理内存。

方案一：如果使用一个JVM部署，那么势必GC会占用大量时间。所以为了快一些，使用之前说过的ZGC可算是一种解决方案。其实书中的想法和我自己的思路比较一致，目标应该都是减少full
gc。
书中的最终方案是尽量保证full GC发生在晚上或者定时。我的思路会更加暴力一些，最好就完全不做full
gc。因为网站的服务主要是在线文档管理，其实IO会比较多，如果可以合理的分配线程，感觉不是做不到完全阻止full gc。
如果可以一周才做一次full gc，那效率还是会高很多。为了实现这个，可以考虑重新设计对象，尽量控制老年代的对象的数量，让大部分对象在young
gc的时候就被回收，也可以适当的扩容新生代的大小。
如果用G1的话可以考虑把survivor比例调小来最大程度的保证新生代不过多触发young gc。

方案二：这个比较好控制，就是保证各个VM直接通信安全即可。当然还需考虑负载均衡的问题，这个更多的是设计思路上面的考量。

## 堆外内存导致的溢出错误

案例：学校的电子考试系统。硬件很差，只有内存只有4G，32位操作系统。问题是服务端不定时会抛出内存溢出异常。尝试过加大堆内存，但是由于硬件限制最高也只能到1.5G。

分析：导致一致抛异常的原因其实很简单，直接内存不够用了。虽然我们可以通过参数限制堆内存，但是直接内存是不会被计入这中间的。

方案：很简单，就是在直接内存到达阈值的时候加一个gc即可，保证直接内存不会抛出异常。这让也会减少full gc的可能性