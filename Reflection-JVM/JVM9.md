# java内存模型和线程

多线程的时候已经讨论很太多次这个部分了，这次我就整理了之前没详细讨论的。

## 主内存和工作内存

所有的变量都会存在主存上，不过这里的变量指的是实例，静态字段和数组的元素。因为其它的局部变量和方法参数都是线程私有的。所谓的主存和硬件上的主存有类似的地方，
一般来说，主存是虚拟机内存的一部分，也就是占用了一部分的物理内存。

每一条线程也会拥有它自己单独的工作内存，工作内存中保存了此线程需要使用的变量的主存副本。线程对变量的修改不会立即对主存可见，而是通过读写来改动。
所以才会出现可见性的问题。

## 内存间的交互操作

内存中对变量的操作

- lock 锁定：主要对于主内存的变量，把一个变量标识为一条线程独占的状态
- unlock 解锁：把一个被锁住的变量释放，同样也在主存中
- read 读取：把一个变量的值从主存输出到线程的工作内存，同样针对主存中的变量
- load 载入：把read得到的变量载入工作内存中，针对的是工作内存的变量
- use 使用：把工作内存中变量的值传递给执行引擎。
- assign 赋值：从执行引擎中接收修改后的值，从新赋给工作内存中的变量
- store 储存：把工作内存中的变量输出到主存
- write 写入：把store得到的值写入主存

对于VM来说，以上的8个操作又必须满足以下的规则

- read/load或者store/write必须成对存在，不能出现主存输入到了工作内存，但是工作内存拒绝加载。
- 一个线程不可放弃它的assign操作，即工作内存中如果修改了变量，那么必须同步到主存
- 一个线程在没有出现assign的情况下，没有资格修改主存的变量
- 变量整个生命周期必须在主存中，单一线程如果想要初始化一个变量，也必须先是load或者assign
- 一个变量同时只能加一把锁，但是可重入
- 对一个变量加锁后，工作内存中此变量的值直接归零，需要重新载入或者赋值
- 没有锁的对象不可以被解锁，线程只能解锁自己锁住的变量
- 解锁一个变量前必须前同步到主存

上述的操作其实都是为了保证线程安全。也就是所谓的一致性，可见性等

## long和double的特殊规则

其实就是JVM规范里面对32位虚拟机的一个条件放宽。VM规范表示：没有volatile修饰的64位数据的读写操作可以被分为2个32位来单独操作。这个情况在64位虚拟机上基本不存在，
而基本上各大平台的虚拟机上也都不太存在这个问题。再加上我们也没有用32位的虚拟机。

## 并发三要素

这个也是讨论过了，这里补充一个之前漏掉的点

在有序性中，有一个说法是Within-Thread As-If-Serial Semantics，表示的是本地线程中观察代码，所有操作都是有序的。

## happens-before 先行发生原则

先行发生意思是Java内存模型中定义的两个操作之间的偏序关系。也就是谁会影响谁。如果我需要A先于B发生，那么逻辑上就能证明A的操作结果会影响B，所以我们需要happens before。
这里所谓的影响，带入到线程视角，不就是变量的值发生改变等。那么举个最简单的例子

```java
a = 1;  // 操作1
b = a;  // 操作2
a = 3;  // 操作3
```

如果我尝试打印b的值，可能会出现两种结果1或者3。因为操作3表面看上去和操作2无关，在指令重排序的时候，很有可能操作2无法捕捉它和操作3的关系。那么就会把操作3放到前面去，
导致b的值和预期不同。

为了解决这种指令重排序的问题，虚拟机规范规定了如下的原则

- 程序次序规则 Program Order Rule：一个线程内，按照控制流的顺序，写在前面的代码应该先于后面的发生
- 管程锁定规则 Monitor Lock Rule：一个解锁操作先于后面代码中对同一个对象的加锁操作
- volatile变量规则 Volatile Variable Rule：对一个volatile变量的写操作一定先于后面对这个变量的读操作
- 线程启动规则 Thread Start Rule：线程的start()方法先于此线程的所有其它操作
- 线程终止规则 Thread Termination Rule：线程中的所有操作都先于线程的终止检测
- 线程中断规则 Thread Interruption Rule：对线程interrupt()方法的调用先发生于被中断线程中检测中断的代码行
- 对象终结规则 Finalizer Rule：对象的初始化一定早于finalize()
- 传递性 Transitivity：如果操作A先于B，B先于C，那么A先于C

凡是不属于以上规定的指令，JVM规范表示，虚拟机可以自行重排序，想怎么排就怎么排。特别注意，以上的先发生表示的是这个指令会先于后面的指令发生，但是和时间没有关系。

## 线程的实现

这里讨论的不再是java中的线程实现，而是更广义的硬件中的线程实现。这个部分之前开会的时候有讨论过，正好整理一下。✌️！

### 内核线程实现

也可叫做1比1实现。内核线程就是直接有操作线程内核(Kernel)支持的线程。内核通过操纵调度器(Scheduler)对线程进行调度，并负责把线程的任务映射到处理器上。
每个内核线程就可以被看成一个内核的副本，所谓的多线程内核就是可以同时处理多种事情的内核。

一般来说，程序无法直接使用内核线程，而是通过叫做Light Wright Process的轻量级进程(接口)。而这个LWP的使用也具有局限性，就像开会的时候说的，
系统需要在用户态和内核态中来回切换。而因为每一个LWP都需要一个内核支持，所以LWP会消耗一定的内核资源，也就是数量收到内核的限制。

### 用户线程实现

一般称为1：N实现。非内核线程的线程一般都可以叫做用户线程。相比于轻量级线程，用户线程不需要得到内核的支持，但是也需要用户自己去管理一个线程的生命周期。
我个人的理解是，可以把用户线程类比成java中我们自己定义的线程，所有开始和销毁都是通过代码层面来实现的。而内核线程则类比成操作系统本身接收到java的代码后，启动的硬件线程，
这是由操作系统控制的，用户没有办法控制。

既然如此，用户线程的好处也很明显，不需要内核的支持。不够管理的难度和资源分配的方案都需要用户自己去考虑，这个太复杂了，所以很多语言其实不倾向于用这个。

### 混合实现

把前两个线程混在一起用。具体底层过于复杂，我就省略了。

### Java线程实现

在java平台上开发的虚拟机其实控制了java线程到底使用以上哪一种方式实现。我目前查到的是，OpenJDK的Hotspot使用的依旧是1比1实现，也就是全部交给操作系统的分配。
但是OracleJDK的HotSpot是否也是这个我没找到具体的说明，我猜应该也差不了太多。

## java线程调度

线程调度一般分为两种方式，分别是协同式线程调度(Cooperative Threads-Scheduling)和抢占式线程调度(Preemptive Threads-Scheduling)。

协同式就是线程自己控制运行时间，直到运行完毕才通知操作系统切换线程。这种模式虽然实现简单，但是一眼就能看出问题。如果代码逻辑出问题，其它线程都会被阻塞住。

抢占式线程调度则是系统来分配运行时间，线程的切换不由线程来决定。java就是使用这种类型。任何一个线程没有办法主动换取CPU时间。虽然可以通过线程优先级来辅助线程获得CPU，
但是java中的优先级和操作系统的优先级也不同，而且优先级这个概念本身就不是很好。所以不建议使用。

## 状态转换

直接略过了，这个部分已经说过无数次了。

## java与协程

如果所有的线程都映射到系统的内核线程中，切换的调度成本会过大。这是因为系统需要不断的切换用户态和内核态，而这种切换需要保证响应中断，保护和恢复不出问题。
也就是说，线程1跑到一半要被换下去，那么就需要把已经运行过的内容保存下来，并且要保证线程1不会出现打断后不能继续的情况。同样线程2也需要记录所有的状态。
发生切换的时候，不只是CPU的调度器在工作，寄存器等都要切换和改变内容，那么必然带来很大的开销。

所谓的协程就是指被设计成协同是调度的用户线程。简单的理解就是原先一个线程上下文切换等于是从内核态变成用户态然后在切换，而引入协程后，则是直接在用户态切换。
这样就可以节省掉之前说的消耗。但是目前JDK 17并不支持协程，我看了一下oracle自己的openJDK项目里面有一个loom的项目应该是实验协程的。不过目前刚加入JDK 19。
相关的JEP还没细看，不过我看了网上一些相关的文章，感觉这个东西的呼声挺高的。

# 总结

至此，整本java虚拟机就总结完了。其实还是省略了不少内容的，主要是重复的部分和我们暂时用不到的部分。个人感觉很多东西还是不够熟悉，现在基本上出现了简单的JVM问题能够知道为什么了。
比如OOM，SOF的简单的成因分析啥的。后面应该会找时间多分析分析我们的JFR，最近也在和ryan学怎么定位问题和分析。下一阶段应该就是Spring了，spring好像没有什么特别好的资料。
我就按照官网的学吧，然后如果碰上了底层的问题，我估计就先找源码或者网上的一些说法，然后尝试验证一下。