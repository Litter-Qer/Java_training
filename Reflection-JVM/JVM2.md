# Java垃圾收集

算是java最为强大的功能，也是为什么很多人选择java而不是C的原因。

## Reference Counting 引用计数算法

就是简单的计算对象被引用的次数，如果被引用了就加一，没有就减一。等到垃圾回收的时候，如果出现了等于0那么就直接回收。实际上python就是利用这个思路来处理垃圾回收的（配合了一些其他复杂的逻辑）

显然这种算法的缺陷很大，如果出现两个对象同时引用对方，那么即使后面它们不在被使用，依旧不会被收集。当然它的效率确实也很高，因为只需要简单的判断一个值即可。但是如果一段程序过于复杂，那么这种简单的方法就不在适用。

## Reachability Analysis 可达性分析算法

有点像NLP里面一个Recursive Tree算法。通过一个根节点不断的向下延申，只要是到达不了根节点的对象最后都会被收集。其实这个算法很多主流的语言都在使用比如java，C#等。
那么这个所谓的根节点叫做GC Roots，从root出发所走过的路叫做Reference Chain。

那么问题来了，如何才能找到根节点呢？其实java也给出了解释。

- 在栈帧本地变量表中引用的对象
- 方法区中静态属性引用的对象
- 方法区中常量引用的对象(比如字符串常量池)
- 本地方法栈中JNI引用的对象
- JVM内部的引用，比如Class，ClassLoader，Exceptions等
- 同步锁持有的对象 synchronized的锁对象
- 反应JVM内部情况的JMXBean等

当然以上并不是全部，对于不同的GC方案和实现，还有可能加入不同的类。这个部分会在后面讨论到