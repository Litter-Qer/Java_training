1. 插入排序
a) 基础的插入排序，主要步骤是将新的元素插入到已经排好的序列中。
实现过程中主要需要注意两个部分，第一个是双重循环的部分，第二个是判定条件。
双重循环主要需要注意：第一个循环应该是从左至右，每一次index都要看过去。
第二个循环主要在判定条件，由于我实现的插入排序，是将后面的值一个一个插入到前面已经排好的序列，
所以算法的稳定性就需要是用判断条件来保证。
while(j>=0 && arr[j] > pivot) 此判定条件保证了稳定性
while(j>=0 && arr[j] >= pivot) 此条件无法保证稳定性
这里的等于号的使用会使原本已经排在前面的值往后平移一个位置，也就失去了稳定性。

b) 编译后的结果
我测试了以下昨天发现的i++的问题，目前为止，所有的i++在编译的时候都会自动编译成++i。
像是某种机制。。。
然后发现javac会把while循环自动翻译成for循环。
只要不是无线循环的情况下，javac会把本来的while编码成一个带条件的for loop
while(j>=0 && arr[j] > pivot)
for(j = i - 1; j >= 0 && arr[j] > pivot; --j)

2. 冒泡排序
a) 主要的探究点，和上面的插入大致相同。双重循环和判定条件
双重循环的要点：
第一个循环应该使用length-1作为结束条件，而第二个循环应该使用length-i-1作为结束条件。
第一个循环主要的意义是将所有元素都过一遍，正好和插入排序相反，冒泡排序其实是把大的元素
往后面插，也就是array的后面是排好序的而前面是需要插入的。
第二个循环的意义是把当前选择的元素和后面的比较，通过交换使得后面的array依旧是排好序的
判定条件：
和插入排序类似，判定条件主要是在于=的应用上
if (arr[j] > arr[j + 1]) 具备稳定性
if (arr[j] >= arr[j + 1]) 不具备稳定性
如果使用等号则排序的时候会把已排好的在交换一次，所以失去稳定性。
编写bubble sort的时候，可以加入一个isSwap变量来判断是否需要换位，
如果不需要换位的话，可以节省一部分判断的时间，提高代码效率。对于相对长一些的
array或者基本sort差不多的array可以节省大量时间。

b) 反编译的结果
我尝试了预先初始化一个temp并且赋值，然后在循环中更改temp的值
以下是反编译后的结果
int temp = false;
        ...
        int temp = arr[j];
很有意思的是无论是提前定义temp还是在if中定义，javac都会把temp在if里面
重新定义一次。于是调整了temp的类型
Integer temp = 0;
        ...
        temp = arr[j];
这里javac就在外部先定义了temp,然后在if中进行了修改。
由此可以发现，javac在处理外部定义的时候，会把Object类型的变量在外部
初始化。而非primitive类型的变量则会直接在使用是定义。
具体原因也许是在内存中的占用空间不同，也可能是Object需要具体的地址，而primitive不用？

3. 多维数组
a) 初始化，随便初始化一个多维的array，不进行赋值的话，java会使用
primitive类型的默认值给这个array填满。
在内存结构中，无论是多少维度的array，它所占据的内存空间应该都是连续的，而不是分段排列的
只是我们人为的将其看成是一个多维的矩阵

b) 任务：算出一个2D数组每一行的总和
第一种方法
基础的多重循环，遍历每一个元素，然后把元素放入array中
第二种方法
使用stream减少循环的使用量，优化代码的结构和美观度
第三种方法
使用foreach和stream，提高代码的可读性。而且减少使用index

三种方法的速度差距基本不大，只是有stream的方法，代码的行数和美观度有提升。
而且使用foreach和stream不需要考虑多维数组的长度问题，直接调用即可。

c) 反编译结果
使用foreach的method，反编译的结果比较不同，其他的两个都比较基本，没有什么新奇的点。
源码
for (int[] row: scores) {
            temp[i] = Arrays.stream(row).sum();
            i++;
        }
foreach反编译的结果
int[][] var5 = scores;
int var6 = scores.length;
    for(int var7 = 0; var7 < var6; ++var7) {
        int[] row = var5[var7];
        temp[i] = Arrays.stream(row).sum();
        ++i;
    }

更具上面的例子，可以发现foreach的底层使用的是普通的for loop的遍历方法。
这种方式也算是java当中的一个语法糖。

4. 杨辉三角
a) 基本逻辑就是一个双重循环中加入一个单次的循环来赋值
主要需要注意的点是杨辉三角的数组并不是一个被填满的矩阵
也就是说每一行的长度是不同的，那么就行遍历的时候需要特别注意index的取值
虽然有三个循环，但是第三个循环只是用来赋值，所以不会影响二维三角的形状
本次实现的时候，尽量减少了system.out.print的使用，加速了代码的运行，
相应需要append string的地方也都使用message format优化了可读性。

b) 反编译的结果
基本上杨辉三角的反编译结果就是前面所有任务的一个综合
大部分的问题都在前面解释过了，唯一可能之前没有注意到的是：
我发现好像javac编译for的时候，会把i放到外面。但是不影响整体结构和使用。

5. Spock测试
今天大概尝试了一下，看了Data Driven Test的文档。
感觉还是比较模糊，后面会继续跟进。






